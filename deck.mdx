import Prism from "prismjs";
import "prismjs/components/prism-elixir";
import "prismjs/components/prism-erlang";
import { CodeSurfer, CodeSurferColumns, Step } from "code-surfer";
import { github } from "@code-surfer/themes";
import { Notes, Footer, Image, Appear, Steps } from "mdx-deck";
import { themes } from "mdx-deck";
export const theme = {
  ...github,
  ...{
    colors: { ...github.colors, background: "white" },
    styles: {
      root: {},
      a: {
        color: "#417be6",
        textDecoration: "none",
      },
    },
  },
};

import traceError from "./images/trace-error.png";
import traceOK from "./images/trace-ok.png";
import punch from "./images/punch.gif";

# Debugging Elixir (with Recon)

## [@jeffutter](https://twitter.com/jeffutter "Jeffery Utter")

---

## What is 'Debugging Live Systems'?

<Steps>

- Not Tracing
- Not Monitoring
- Not Step Debugging
- **Last Resort for Production Issues**

</Steps>

---

## Tracing

<Appear>

Sometimes the error is obvious!

<Image src={traceError} width="80vw" size="contain" />

</Appear>

---

## Tracing

<Appear>

Sometimes the error is nowhere to be found!

<Image src={traceOK} width="80vw" size="contain" />

Enter Remote Debugging!

</Appear>

---

## Tools built in to the BEAM

---

### Step 1: Remote console

---

### Step 2: Beam Debugging Tools

Of course the beam comes with built in debugging tools!

---

<Steps>

- `:sys` module
- **`:erlang.trace` / `:erlang.trace_pattern`**
- **`:dbg`**

</Steps>

---

### What you really want?

<Steps>

- **RECON**

</Steps>

---

### The tracing process

All tracing methods require a trace process that receives trace messages.

Recon gives you a **robust** one out of the box.

---

### Let's look at a naive one

---

<CodeSurfer>

```elixir title="Trace Process" 2:4
defmodule Tracer do
  def start do
    spawn(&loop/0)
  end

  def loop do
    receive do
      msg ->
        IO.inspect(msg)
        loop()
    end
  end
end
```

```diff title="Trace Process" 6:12

```

</CodeSurfer>

<Notes>

- Receives traces messages and logs them to the console

</Notes>

---

### A test process

---

<CodeSurfer>

```elixir title="A test process"
defmodule Echo do
  def start do
    spawn(&loop/0)
  end

  def call(pid, msg) do
    send(pid, {self(), msg})

    receive do
      msg ->
        msg
    end
  end

  defp loop do
    receive do
      {from, message} when is_pid(from) ->
        send(from, message)
        loop()
    end
  end
end
```

```diff title="A test process" subtitle="Run a process in a loop" 2:4

```

```diff title="A test process" subtitle="Receive a message and send back the same message" 15:21

```

```diff title="A test process" subtitle="Public function to call the process and wait for response" 6:13

```

</CodeSurfer>

---

### `:erlang.trace`

<Notes>

- BIF
- Foundation for all other tracing tools in the BEAM

</Notes>

---

### Trace a process

---

<CodeSurfer>

```elixir subtitle="Start the process and trace logger"
iex(1)> echo_pid = Echo.start()
#PID<0.125.0>
iex(2)> tracer_pid = Tracer.start()
#PID<0.127.0>
```

</CodeSurfer>

---

<CodeSurfer>

```elixir subtitle="Setup tracing"
iex(3)> :erlang.trace(echo_pid, true, [:all, {:tracer, tracer_pid}])
1
```

```elixir subtitle="Call the echo process"
iex(3)> :erlang.trace(echo_pid, true, [:all, {:tracer, tracer_pid}])
1
iex(4)> Echo.call(echo_pid, :hi)
:hi
{:trace_ts, #PID<0.125.0>, :in, {Echo, :loop, 0}, 3, {1588, 360682, 682641}}
{:trace_ts, #PID<0.125.0>, :receive, {#PID<0.109.0>, :hi}, 3, {1588, 360682, 682645}}
{:trace_ts, #PID<0.125.0>, :send, :hello, #PID<0.109.0>, 3, {1588, 360682, 682648}}
{:trace_ts, #PID<0.125.0>, :out, {Echo, :loop, 0}, 3, {1588, 360682, 682650}}
```

```diff subtitle="Timestamp Traces" 5[1:10],6[1:10],7[1:10],8[1:10]

```

```diff subtitle="Pid that was traced" 5[13:25],6[13:25],7[13:25],8[13:25]

```

```diff subtitle="Trace Event" 5[28:30],6[28:35],7[28:32],8[28:31]

```

```diff subtitle="Event Details" 5[33:48],6[38:57],7[35:55],8[34:49]

```

```diff subtitle="I have no idea!" 5[51],6[60],7[58],8[52]

```

```diff subtitle="Timestamp" 5[54:75],6[63:84],7[61:82],8[55:76]

```

</CodeSurfer>

<Notes>

- trace_ts = trace_timestamp
- The time stamp (Ts) has the same form as returned by erlang:now(): {MegaSecs, Secs, MicroSecs}
- in/out schedule
- Turns on (if How == true) or off (if How == false) the trace flags in FlagList for the process or processes represented by PidPortSpec.
- Tracer options: all | send | 'receive' | procs | ports | call | arity | return_to | silent | running | exiting | running_procs | running_ports | garbage_collection | timestamp | cpu_timestamp | monotonic_timestamp | strict_monotonic_timestamp | set_on_spawn | set_on_first_spawn | set_on_link | set_on_first_link |

</Notes>

---

### `:erlang.trace` Options

---

<CodeSurfer>

```erlang title=":erlang.trace Options"
erlang:trace(PidPortSpec, How, FlagList) -> integer()
Types
PidPortSpec =
    pid() |
    port() |
    all | processes | ports | existing | existing_processes |
    existing_ports | new | new_processes | new_ports
How = boolean()
FlagList = [trace_flag()]
trace_flag() =
    all | send | 'receive' | procs | ports | call | arity |
    return_to | silent | running | exiting | running_procs |
    running_ports | garbage_collection | timestamp |
    cpu_timestamp | monotonic_timestamp |
    strict_monotonic_timestamp | set_on_spawn |
    set_on_first_spawn | set_on_link | set_on_first_link |
    {tracer, pid() | port()} |
    {tracer, module(), term()}
```

</CodeSurfer>

---

### Trace a function

---

<CodeSurfer>

```elixir subtitle="Start the trace collector"
iex(1)> pid = Trace.start()
#PID<0.118.0>
```

```elixir subtitle="Enable tracing"
iex(1)> pid = Trace.start()
#PID<0.118.0>
iex(2)> :erlang.trace(:all, true, [:call, {:tracer, pid}])
59
```

```elixir subtitle="Set the trace pattern"
iex(1)> pid = Trace.start()
#PID<0.118.0>
iex(2)> :erlang.trace(:all, true, [:call, {:tracer, pid}])
59
iex(3)> :erlang.trace_pattern({String, :downcase, 1}, true, [])
1
```

```elixir subtitle="Do something traceable"
iex(1)> pid = Trace.start()
#PID<0.118.0>
iex(2)> :erlang.trace(:all, true, [:call, {:tracer, pid}])
59
iex(3)> :erlang.trace_pattern({String, :downcase, 1}, true, [])
1
iex(4)> String.downcase("FOO")
"foo"
{:trace, #PID<0.109.0>, :call, {String, :downcase, ["FOO"]}}
```

```elixir subtitle="Stop the trace"
iex(1)> pid = Trace.start()
#PID<0.118.0>
iex(2)> :erlang.trace(:all, true, [:call, {:tracer, pid}])
59
iex(3)> :erlang.trace_pattern({String, :downcase, 1}, true, [])
1
iex(4)> String.downcase("FOO")
"foo"
{:trace, #PID<0.109.0>, :call, {String, :downcase, ["FOO"]}}
iex(5)> :erlang.trace(:all, false, [:call, {:tracer, pid}])
59
iex(6)> String.downcase("FOO")
"foo"
```

</CodeSurfer>

---

### `:dbg`

- Wrapper around `:erlang.trace`
- Handles starting the trace process
- Robust, ~150 lines of erlang
- Supports tracing other nodes

---

### Trace a process

---

<CodeSurfer>

```elixir subtitle="Start the process"
iex(1)> echo_pid = Echo.start
#PID<0.118.0>
```

```elixir subtitle="Setup tracing on the local node"
iex(1)> echo_pid = Echo.start
#PID<0.118.0>
iex(4)> :dbg.tracer()
{:ok, #PID<0.120.0>}
```

```elixir subtitle="Setup tracing on the process"
iex(1)> echo_pid = Echo.start
#PID<0.118.0>
iex(4)> :dbg.tracer()
{:ok, #PID<0.120.0>}
iex(5)> :dbg.p(echo_pid, [:all])
{:ok, [{:matched, :nonode@nohost, 1}]}
```

```elixir subtitle="Call the process"
iex(1)> echo_pid = Echo.start
#PID<0.118.0>
iex(4)> :dbg.tracer()
{:ok, #PID<0.120.0>}
iex(5)> :dbg.p(echo_pid, [:all])
{:ok, [{:matched, :nonode@nohost, 1}]}
iex(6)> Echo.call(echo_pid, :hi)
:hi
(<0.118.0>) in {'Elixir.Echo',loop,0} (Timestamp: {1588,724836,891436})
(<0.118.0>) << {<0.109.0>,hi} (Timestamp: {1588,724836,891679})
(<0.118.0>) <0.109.0> ! hi (Timestamp: {1588,724836,891684})
(<0.118.0>) out {'Elixir.Echo',loop,0} (Timestamp: {1588,724836,891687})
```

```elixir subtitle="Stop and cleanup"
iex(1)> echo_pid = Echo.start
#PID<0.118.0>
iex(4)> :dbg.tracer()
{:ok, #PID<0.120.0>}
iex(5)> :dbg.p(echo_pid, [:all])
{:ok, [{:matched, :nonode@nohost, 1}]}
iex(6)> Echo.call(echo_pid, :hi)
:hi
(<0.118.0>) in {'Elixir.Echo',loop,0} (Timestamp: {1588,724836,891436})
(<0.118.0>) << {<0.109.0>,hi} (Timestamp: {1588,724836,891679})
(<0.118.0>) <0.109.0> ! hi (Timestamp: {1588,724836,891684})
(<0.118.0>) out {'Elixir.Echo',loop,0} (Timestamp: {1588,724836,891687})
iex(8)> :dbg.stop_clear()
:ok
```

</CodeSurfer>

---

### Trace a function

---

<CodeSurfer>

```elixir subtitle="Start the tracer and setup tracing for all processes"
iex(1)> :dbg.tracer()
{:ok, #PID<0.111.0>}
iex(2)> :dbg.p(:all,:c)
{:ok, [{:matched, :nonode@nohost, 60}]}
```

```elixir subtitle="Setup tracing for the function"
iex(1)> :dbg.tracer()
{:ok, #PID<0.111.0>}
iex(2)> :dbg.p(:all,:c)
{:ok, [{:matched, :nonode@nohost, 60}]}
iex(3)>  :dbg.tpl(String, :downcase, :x)
{:ok, [{:matched, :nonode@nohost, 2}, {:saved, :x}]}
```

```elixir subtitle="Call the function"
iex(1)> :dbg.tracer()
{:ok, #PID<0.111.0>}
iex(2)> :dbg.p(:all,:c)
{:ok, [{:matched, :nonode@nohost, 60}]}
iex(3)>  :dbg.tpl(String, :downcase, :x)
{:ok, [{:matched, :nonode@nohost, 2}, {:saved, :x}]}
iex(4)> String.downcase("HI")
(<0.109.0>) call 'Elixir.String':downcase(<<"HI">>)
(<0.109.0>) call 'Elixir.String':downcase(<<"HI">>,default)
(<0.109.0>) returned from 'Elixir.String':downcase/2 -> <<"hi">>
(<0.109.0>) returned from 'Elixir.String':downcase/1 -> <<"hi">>
"hi"
```

```elixir subtitle="Cleanup"
iex(1)> :dbg.tracer()
{:ok, #PID<0.111.0>}
iex(2)> :dbg.p(:all,:c)
{:ok, [{:matched, :nonode@nohost, 60}]}
iex(3)>  :dbg.tpl(String, :downcase, :x)
{:ok, [{:matched, :nonode@nohost, 2}, {:saved, :x}]}
iex(4)> String.downcase("HI")
(<0.109.0>) call 'Elixir.String':downcase(<<"HI">>)
(<0.109.0>) call 'Elixir.String':downcase(<<"HI">>,default)
(<0.109.0>) returned from 'Elixir.String':downcase/2 -> <<"hi">>
(<0.109.0>) returned from 'Elixir.String':downcase/1 -> <<"hi">>
"hi"
iex(5)> :dbg.stop_clear()
:ok
```

</CodeSurfer>

---

### Pitfalls of `:erlang.trace` and `:dbg`

<Steps>

- Arguably confusing interface
- Potential to dump unbounded amounts of tracing
- Ability to deadlock

</Steps>

---

## Recon

<Steps>

- `:erlang.trace` wrapper by Fred Hebert
- Production Safe!
  - Tracer links to shell (group leader)
  - Formatter links to tracer
  - Gracefully shuts down on remote shell disconnect
  - Enforces limited count of traces
- Single node only

</Steps>

---

### Trace a function

---

<CodeSurfer>

```elixir subtitle="Setup trace for the function call"
iex(1)> :recon_trace.calls({String, :downcase, :return_trace}, 2)
2
```

```diff subtitle="Return trace shortcut" 1[48:60]

```

```diff subtitle="Limit number of calls" 1[64]

```

```elixir subtitle="Call the function"
iex(2)> String.downcase("HI")
"hi"

9:24:54.599054 <0.682.0> 'Elixir.String':downcase(<<"HI">>)

9:24:54.607330 <0.682.0> 'Elixir.String':downcase/1 --> <<"hi">>
Recon tracer rate limit tripped.
```

</CodeSurfer>

---

- 3rd argument to tuple can be match spec
  ```
  :recon_trace.calls({String, :downcase, match_spec}, _)
  ```
- `:recon_trace.calls/3` takes a 3rd argument that can specify the pid to trace among other things
- Private Functions: `:recon_trace.calls({x, y, z}, 2, [scope: :local])`

---

### Match Specs

---

<CodeSurfer>

```elixir subtitle="Setup a matchspec"
iex(1)> :recon_trace.calls({String, :downcase, [{[:"$1"], [{:==, :"$1", "HI"}], [{:return_trace}]}]}, 2)
2
```

```diff 1[47:99]

```

```elixir
iex(1)> :recon_trace.calls({String, :downcase, [{[:"$1"], [{:==, :"$1", "HI"}], [{:return_trace}]}]}, 2)
2
iex(2)> String.downcase("foo")
"foo"
```

```elixir
iex(1)> :recon_trace.calls({String, :downcase, [{[:"$1"], [{:==, :"$1", "HI"}], [{:return_trace}]}]}, 2)
2
iex(2)> String.downcase("foo")
"foo"
iex(3)> String.downcase("HI")
"hi"

20:23:19.249978 <0.109.0> 'Elixir.String':downcase(<<"HI">>)

20:23:19.254061 <0.109.0> 'Elixir.String':downcase/1 --> <<"hi">>
Recon tracer rate limit tripped.
```

</CodeSurfer>

---

### The Matchspec

<Steps>

- `[{[:"$1"], [{:==, :"$1", "HI"}], [{:return_trace}]}]`
- Gross
- There is a solution:
- `Ex2ms`

</Steps>

---

<CodeSurfer>

```elixir
iex(1)> Mix.install([{:ex2ms, ">= 0.0.0"}])
```

```elixir
iex(1)> Mix.install([{:ex2ms, ">= 0.0.0"}])
Resolving Hex dependencies...
Dependency resolution completed:
New:
  ex2ms 1.6.0
* Getting ex2ms (Hex package)
==> ex2ms
Compiling 1 file (.ex)
Generated ex2ms app
:ok
iex(2)> import Ex2ms
```

```elixir
iex(1)> Mix.install([{:ex2ms, ">= 0.0.0"}])
Resolving Hex dependencies...
Dependency resolution completed:
New:
  ex2ms 1.6.0
* Getting ex2ms (Hex package)
==> ex2ms
Compiling 1 file (.ex)
Generated ex2ms app
:ok
iex(2)> import Ex2ms
iex(3)> fun do x when x == "HI" -> return_trace() end
```

```elixir
iex(1)> Mix.install([{:ex2ms, ">= 0.0.0"}])
Resolving Hex dependencies...
Dependency resolution completed:
New:
  ex2ms 1.6.0
* Getting ex2ms (Hex package)
==> ex2ms
Compiling 1 file (.ex)
Generated ex2ms app
:ok
iex(2)> import Ex2ms
iex(3)> fun do x when x == "HI" -> return_trace() end
[{:"$1", [{:==, :"$1", "HI"}], [{:return_trace}]}]
```

</CodeSurfer>

---

### Recon Extreme

Recon has tons of options and can be used for some really powerful debugging. Lets take a look.

---

### Cowboy Bug?

I was convinced there was a bug in cowboy, where it was double-emitting telemetry events.

How can we use `:recon` to find the sequence of events that `cowboy` is taking?

<Steps>

- Recon can trace multiple functions in one call
- Let's look at the `io_server` and `formatter` options.

</Steps>

---

<CodeSurfer>

```elixir
functions = [
  {:cowboy_telemetry_h, :init, 3},
  {:cowboy_telemetry_h, :terminate, 3},
  {Hertz.Tracer, :continue_trace, 3},
  {Hertz.Tracer, :start_trace, 2},
  {Hertz.Tracer, :finish_trace, 0}
]

formatter = fn {:trace_ts, pid, :call, {m, f, a}, ts} ->
  "#{format_ts(ts)},#{inspect(pid)},#{m}:#{f},#{format_args(a)}\n"
end

{:ok, fd} = File.open("/tmp/trace", [:write])

:recon_trace.calls(functions, 20000, io_server: fd, timestamp: :trace, formatter: formatter)
```

```diff 1,2,3,4,5,6,7,15[20:28]

```

```diff 9,10,11,15[72:91]

```

```diff 13,15[38:50]

```

```diff

```

</CodeSurfer>

---

<CodeSurfer>

```elixir title="Processing"
File.stream!("/tmp/trace")
|> Stream.map(&String.trim/1)
|> Stream.map(&String.split(&1, ","))
|> Enum.to_list
|> Enum.group_by(
  fn [_ts, pid, _mf, _a] -> pid end,
  fn [ts, _pid, mf, a] -> {ts, mf, a} end
)
|> Enum.map(fn {p, vs} -> {p, Enum.sort_by(vs, &elem(&1, 0))} end)
|> Enum.reject(fn e ->
  match?({_,[{_, "cowboy_telemetry_h:init", _}, {_, "Elixir.Hertz.Tracer:start_trace", _}, {_, "cowboy_telemetry_h:terminate", _}, {_, "Elixir.Hertz.Tracer:finish_trace", _}]}, e)
  || match?({_,[{_, "cowboy_telemetry_h:init", _}, {_, "Elixir.Hertz.Tracer:continue_trace", _}, {_, "cowboy_telemetry_h:terminate", _}, {_, "Elixir.Hertz.Tracer:finish_trace", _}]}, e)
  || match?({_,[{_, "Elixir.Hertz.Tracer:continue_trace", _}, {_, "Elixir.Hertz.Tracer:finish_trace", _}]}, e)
end)
|> Enum.map(fn {p, vs} ->
  [Enum.map(vs, fn
    {t, "Elixir.Hertz.Tracer:start_trace" = mf, a} -> [p, "\t", t, "\t", mf, " ", a, "\n"]
    {t, "Elixir.Hertz.Tracer:continue_trace" = mf, a} -> [p, "\t", t, "\t", mf, " ", a, "\n"]
    {t, mf, _} -> [p, "\t", t, "\t", mf, "\n"]
  end), "\n"]
end)
|> IO.chardata_to_string()
|> IO.puts()
```

</CodeSurfer>

---

<CodeSurfer>

```elixir title="Results"
#PID<0.6986.2161>       001624069591866077      cowboy_telemetry_h:init
#PID<0.6986.2161>       001624069591866107      Elixir.Hertz.Tracer:continue_trace
#PID<0.6986.2161>       001624069591929033      cowboy_telemetry_h:terminate
#PID<0.6986.2161>       001624069592161650      cowboy_telemetry_h:init
#PID<0.6986.2161>       001624069592161680      Elixir.Hertz.Tracer:continue_trace
#PID<0.6986.2161>       001624069592177876      cowboy_telemetry_h:terminate
#PID<0.6986.2161>       001624069592201986      cowboy_telemetry_h:init
#PID<0.6986.2161>       001624069592202063      Elixir.Hertz.Tracer:continue_trace
#PID<0.6986.2161>       001624069592234275      cowboy_telemetry_h:terminate
#PID<0.6986.2161>       001624069593016795      cowboy_telemetry_h:init
#PID<0.6986.2161>       001624069593016827      Elixir.Hertz.Tracer:continue_trace
#PID<0.6986.2161>       001624069593068816      cowboy_telemetry_h:terminate
#PID<0.6986.2161>       001624069593177537      cowboy_telemetry_h:init
#PID<0.6986.2161>       001624069593177580      Elixir.Hertz.Tracer:continue_trace
#PID<0.6986.2161>       001624069593259962      cowboy_telemetry_h:terminate
#PID<0.6986.2161>       001624069593502571      cowboy_telemetry_h:init
#PID<0.6986.2161>       001624069593502608      Elixir.Hertz.Tracer:continue_trace
#PID<0.6986.2161>       001624069593578032      cowboy_telemetry_h:init
#PID<0.6986.2161>       001624069593578090      Elixir.Hertz.Tracer:continue_trace
#PID<0.6986.2161>       001624069593578380      cowboy_telemetry_h:terminate
#PID<0.6986.2161>       001624069593652153      cowboy_telemetry_h:terminate
#PID<0.6986.2161>       001624069594302623      cowboy_telemetry_h:init
#PID<0.6986.2161>       001624069594302652      Elixir.Hertz.Tracer:continue_trace
#PID<0.6986.2161>       001624069594326709      cowboy_telemetry_h:terminate
#PID<0.6986.2161>       001624069594452013      cowboy_telemetry_h:init
#PID<0.6986.2161>       001624069594452043      Elixir.Hertz.Tracer:continue_trace
#PID<0.6986.2161>       001624069594525699      cowboy_telemetry_h:terminate
#PID<0.6986.2161>       001624069595004839      cowboy_telemetry_h:init
#PID<0.6986.2161>       001624069595004872      Elixir.Hertz.Tracer:continue_trace
#PID<0.6986.2161>       001624069595088328      cowboy_telemetry_h:terminate
#PID<0.6986.2161>       001624069595135111      cowboy_telemetry_h:init
```

</CodeSurfer>

---

### Other Recon Features

<Steps>

- `:recon.get_state(pid)`
- `:recon.info(pid)` - safer than `:process_info`
- `:recon.proc_window(attribute, top_n, window_ms)`

</Steps>

---

### Windowed metrics

Any metric from `:process_info`. Such as: `reductions`, `message_queue_len`, `total_heap_size`, etc.

---

<CodeSurfer>

```elixir
iex(socialx@08b823e1c4c4)5> :recon.proc_window(:reductions, 5, 10000)
[
  {#PID<0.4621.0>, 1582423,
   [
     Logger,
     {:current_function, {:gen_event, :fetch_msg, 6}},
     {:initial_call, {:proc_lib, :init_p, 5}}
   ]},
  {#PID<0.26097.235>, 671022,
   [
     current_function: {:cowboy_http, :loop, 1},
     initial_call: {:proc_lib, :init_p, 5}
   ]},
  {#PID<0.27937.151>, 528807,
   [
     current_function: {:cowboy_http, :loop, 1},
     initial_call: {:proc_lib, :init_p, 5}
   ]},
   ...
]
```

</CodeSurfer>

---

## What's left?

<Steps>

- Sequential Tracing `:seq_trace`
  > Sequential tracing is a way to trace a sequence of messages sent between different local or remote processes, where the sequence is initiated by a single message.
  >
  > -- <cite>[Erlang -- seq_trace](https://erlang.org/doc/man/seq_trace.html#whatis)</cite>
- Production safe debugging across nodes
- `:sys` module

</Steps>

---

## Resources

- [Connect to Running Elixir Applications with IEx Remote Shell](http://joeellis.la/iex-remsh-shells/)
- [Tracing in Erlang (Gist)](https://gist.github.com/id/cba5dbf7653d7eab6a03)
- [Recon](https://ferd.github.io/recon/)
- [Erlang in Anger](https://www.erlang-in-anger.com/)
- [Observer Cli](https://github.com/zhongwencool/observer_cli)
- [Debugging Techniques in Elixir](http://blog.plataformatec.com.br/2016/04/debugging-techniques-in-elixir-lang/)
- [Erlang Factory - dbg/ttb](http://www.erlang-factory.com/upload/presentations/316/dbg[1].pdf)

---

# Questions?

<Image src={punch} width="80vw" size="contain" />
